<canvas id="renderCanvas"></canvas>

<script is:inline src="https://preview.babylonjs.com/babylon.js"></script>
<script is:inline src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>
<script is:inline src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
<script is:inline src="https://unpkg.com/earcut@latest/dist/earcut.min.js"></script>
<script is:inlune src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.js"></script>
<script type="text/javascript">
  function main() {
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas);

    function degree(degrees) {
      return degrees * (Math.PI / 180);
    }

    const createScene = function () {
      const scene = new BABYLON.Scene(engine);

      const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
      //camera.position = new BABYLON.Vector3(30, 12, 12);
      camera.position = new BABYLON.Vector3(30, 30, 30);
      camera.attachControl(canvas, true);

      // 光源設定
      // 昼
      // const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      //       light.intensity = .6;

      // 夜
      const spot = new BABYLON.PointLight("spot", new BABYLON.Vector3(5, 5, 5));
      spot.diffuse = new BABYLON.Color3(.7, .7, .7);
      spot.specular = new BABYLON.Color3(0, 0, 0);
      spot.position.y = 20;
      spot.position.x = 45;

      const moon = BABYLON.Mesh.CreateSphere("moon", 10, 4);
      moon.material = new BABYLON.StandardMaterial("moon");
      moon.material.emissiveColor = new BABYLON.Color3(1, 1, 0);  
      moon.position.y = 20;
      moon.position.x = 45;

      const tea = BABYLON.Mesh.CreateSphere("tea", 10, .5);
      tea.material = new BABYLON.StandardMaterial("teamaterial");
      tea.material.diffuseColor = new BABYLON.Color3(1, 1, 1);  
      tea.position.y = 7.9;
      tea.position.x = -27.5;
      tea.position.z = 24;

      const tea1 = tea.clone();
      tea1.position.y = 7.9;
      tea1.position.x = -23.5;
      tea1.position.z = 28.5;

      const tea_under = BABYLON.MeshBuilder.CreateCylinder("tea_under", {height:.5, diameter: .1});
      const tea_under_material = new BABYLON.StandardMaterial("tea_under_material", scene);
      tea_under_material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
      tea_under_material.alpha = .9;
      tea_under.material = tea_under_material;
      tea_under.position.y = 7.5;
      tea_under.position.x = -27.5;
      tea_under.position.z = 24;

      const tea_under1 = tea_under.clone();
      tea_under1.position.x = -23.5;
      tea_under1.position.z = 28.5;

      // 空
      const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000}, scene);
      const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;

            // 昼
            // skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/sky/skybox", scene);
            // skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

            // 夜
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/sky_night/skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
        

      // グランドを作成
      const largeGroundMat = new BABYLON.StandardMaterial("largeGroundMat");
            largeGroundMat.diffuseTexture = new BABYLON.Texture("textures/ground/valleygrass.png");
      
      const largeGround = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", "textures/ground/villageheightmap.png", {width:72, height:72, subdivisions: 200, minHeight:0, maxHeight: 8});
            largeGround.material = largeGroundMat;
            largeGround.rotation.y = degree(90);
            largeGround.position.y = -0.5;

      // カップを作成
      const golfcup = BABYLON.MeshBuilder.CreateCylinder("golfcup", {height:1, depth:0.1});

      const golfcupMaterial = new BABYLON.StandardMaterial("golfcupmaterial", scene);
      golfcupMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
      golfcupMaterial.alpha = .9;
      golfcup.material = golfcupMaterial;
      golfcup.position.x = 32;
      golfcup.position.y = 1.92;
      golfcup.position.z = -10.8;
      golfcup.rotation.z = degree(2);
      golfcup.rotation.x = degree(-3);

      // 水を作成
      var waterMesh = BABYLON.Mesh.CreateGround("waterMesh", 20, 37, 10, scene, false);
      var water = new BABYLON.WaterMaterial("water", scene, new BABYLON.Vector2(512, 512));
      water.backFaceCulling = true;
      water.bumpTexture = new BABYLON.Texture("textures/water/waterbump.png", scene);
      water.windForce = -2;
      water.waveHeight = 0.1;
      water.bumpHeight = 0.1;
      water.waterColor = new BABYLON.Color3(0.1, 0.1, 0.2);
      water.colorBlendFactor = 0.5;
      water.addToRenderList(skybox);
      water.addToRenderList(largeGround);
      waterMesh.material = water;
      waterMesh.position.x = 2.9;      
      waterMesh.position.y = 1.7;
      waterMesh.position.z = 16.5;         

      // 木を作成
      // position x 前 + 後 -
      // position y 上 + 下 -
      // position z 左 + 右 -

      // 昼
      // const spritetree = new BABYLON.SpriteManager("treesManager", "textures/wood/wood.png", 1000, {width: 538, height: 680}, scene);

      // 夜
      const spritetree = new BABYLON.SpriteManager("treesManager", "textures/wood/wood_dark.png", 1000, {width: 538, height: 680}, scene);

        for (let i = 0; i < 270; i++) {
          switch(true) {
            // right side
            case i > 0 && i < 5:
              const treer_1 = new BABYLON.Sprite("tree", spritetree);
              treer_1.width = 2;
              treer_1.height = 3;              
              treer_1.position.x = Math.random() * (1) - (30 + ((5 - i) * 1.1 ));
              treer_1.position.z = Math.random() * -2  - (6 - ((5 - i) * 1.3 ));
              treer_1.position.y = 3.7;
              break;    
            case i > 5 && i < 15:
              const treer_2 = new BABYLON.Sprite("tree", spritetree);
              treer_2.width = 2;
              treer_2.height = 3;              
              treer_2.position.x = Math.random() * (1) - (20 + ((15 - i) * 1.3 ));
              treer_2.position.z = Math.random() * -1  - (11- ((15 - i) * .7 ));
              treer_2.position.y = 3.7;
              break;   
            case i > 15 && i < 25:
              const treer_3 = new BABYLON.Sprite("tree", spritetree);
              treer_3.width = 2;
              treer_3.height = 3;              
              treer_3.position.x = Math.random() * (1) - (10 + ((25 - i) * 1.3 ));
              treer_3.position.z = Math.random() * -1  - (14 - ((25 - i) * .4 ));
              treer_3.position.y = 3.5;
              break;
            case i > 25 && i < 35:
              const treer_4 = new BABYLON.Sprite("tree", spritetree);
              treer_4.width = 2;
              treer_4.height = 3;              
              treer_4.position.x = Math.random() * (1) - (0 + ((35 - i) * 1.3 ));
              treer_4.position.z = Math.random() * -1  - (17 - ((35 - i) * .4 ));
              treer_4.position.y = 3.5;
              break;
            case i > 35 && i < 45:
              const treer_5 = new BABYLON.Sprite("tree", spritetree);
              treer_5.width = 2;
              treer_5.height = 3;              
              treer_5.position.x = Math.random() * (1) + (11 - ((45 - i) * 1.3 ));
              treer_5.position.z = Math.random() * -1  - (19.5 - ((45 - i) * .4 ));
              treer_5.position.y = 3.5;
              break;
            case i > 45 && i < 65:
              const treer_7 = new BABYLON.Sprite("tree", spritetree);
              treer_7.width = 2;
              treer_7.height = 3;              
              treer_7.position.x = Math.random() * 1 + (35 - ((65 - i) * 1.3 ));
              treer_7.position.z = Math.random() * -1  - (30.5 - ((65 - i) * .6));
              treer_7.position.y = 3.5;
              break;
            // front area
            case i > 65 && i < 150:
              const treef_1 = new BABYLON.Sprite("tree", spritetree);
              treef_1.width = 2;
              treef_1.height = 3;              
              treef_1.position.x = Math.random() * (15) - 23;
              treef_1.position.z = Math.random() * 15  - 4;
              treef_1.position.y = 3.8;
              break;
            case i > 150 && i < 180:
              const treef_2 = new BABYLON.Sprite("tree", spritetree);
              treef_2.width = 2;
              treef_2.height = 3;              
              treef_2.position.x = Math.random() * (6) - 18;
              treef_2.position.z = Math.random() * 10  + 6;
              treef_2.position.y = 3.8;
              break;
            case i > 180 && i < 200:
              const treef_3 = new BABYLON.Sprite("tree", spritetree);
              treef_3.width = 2;
              treef_3.height = 3;              
              treef_3.position.x = Math.random() * (6) - 13;
              treef_3.position.z = Math.random() * 6  + 14;
              treef_3.position.y = 3.8;
              break;
            case i > 200 && i < 220:
              const treef_4 = new BABYLON.Sprite("tree", spritetree);
              treef_4.width = 2;
              treef_4.height = 3;              
              treef_4.position.x = Math.random() * (6) - 10;
              treef_4.position.z = Math.random() * 6  + 20;
              treef_4.position.y = 3.8;
              break;
            case i > 220 && i < 250:
              const treef_5 = new BABYLON.Sprite("tree", spritetree);
              treef_5.width = 2;
              treef_5.height = 3;              
              treef_5.position.x = Math.random() * (6) - 8;
              treef_5.position.z = Math.random() * 8  + 27;
              treef_5.position.y = 3.8;
              break;
            default:
              const tree = new BABYLON.Sprite("tree", spritetree);
              tree.width = 2;
              tree.height = 3;                 
              tree.position.x = Math.random() * (-5) + 19;
              tree.position.z = Math.random() * 8 + 27;
              tree.position.y = 3.5;
              break;
          }
        }
        
        // ランプを作成
        BABYLON.SceneLoader.ImportMeshAsync("", "", "lamp.babylon").then(() =>{
          const lampLight = new BABYLON.SpotLight("lampLight", BABYLON.Vector3.Zero(), new BABYLON.Vector3(0.3, -1, 0), 0.7 * Math.PI, 0.01, scene);
          lampLight.diffuse = BABYLON.Color3.Yellow();
          lampLight.parent = scene.getMeshByName("bulb")

          const lamp = scene.getMeshByName("lamp");
          lamp.position = new BABYLON.Vector3(2, 2, 2); 
          lamp.rotation = BABYLON.Vector3.Zero();
          lamp.rotation.y = -Math.PI / 2;
          lamp.position.x = 23;
          lamp.position.z = -27;

          lamp3 = lamp.clone("lamp3");
          lamp3.position.z = -20;
          lamp3.position.x = 0;

          lamp1 = lamp.clone("lamp1");
          lamp1.position.z = -12;
          lamp1.position.x = -23;


      });

        // 噴水を作成
        BABYLON.SceneLoader.ImportMeshAsync("", "", "fountain.babylon").then(() =>  {

          const fountain = scene.getMeshByName("fountain");
          fountain.position.x = -27.7;
          fountain.position.y = 2.3;
          fountain.position.z = 6.8;

          var particleSystem = new BABYLON.ParticleSystem("particles", 5000, scene);

          particleSystem.particleTexture = new BABYLON.Texture("textures/flare/flare.png", scene);

          particleSystem.emitter = new BABYLON.Vector3(-27.7, 6.3, 6.8);
          particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
          particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);

          particleSystem.color1 = new BABYLON.Color4(0.1, 0.1, 0.2, 0.8);
          particleSystem.color2 = new BABYLON.Color4(0.1, 0.1, 0.2, 0.8);
          particleSystem.colorDead = new BABYLON.Color4(0.1, 0.1, 0.2, 0.8);

          // パーティクルのサイズ
          particleSystem.minSize = 0.1 / 2;
          particleSystem.maxSize = 0.8 / 2;

          particleSystem.minLifeTime = 1;
          particleSystem.maxLifeTime = 2.5;

          particleSystem.emitRate = 1500;

          particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

          particleSystem.gravity = new BABYLON.Vector3(0, -3.81, 0);

          // 噴水のばら撒く距離
          particleSystem.direction1 = new BABYLON.Vector3(-.2, 1, .2);
          particleSystem.direction2 = new BABYLON.Vector3(.2, 1, -.2);

          particleSystem.minAngularSpeed = 0;
          particleSystem.maxAngularSpeed = Math.PI;

          particleSystem.minEmitPower = 2;
          particleSystem.maxEmitPower = 3;
          particleSystem.updateSpeed = 0.025;

          particleSystem.start();
        });

      return scene;
    };

    const scene = createScene();
    
    engine.runRenderLoop(() => {
      scene.render();
    });
    
    window.addEventListener('resize', () => {
      engine.resize();
    });
  }
  window.addEventListener('DOMContentLoaded', main);
</script>

<style is:global>
	#renderCanvas {
		width   : 100%;
		height  : 100%;
		touch-action: none;
		top:0;
		left: 0;
	}
</style>