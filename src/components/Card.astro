---

// blog
import { getNsports } from "../../library/microcms";
const resnublog = await getNsports({ fields: ["id", "title", "image", "date"] });

import moment from "moment";
let setdate = function (str:any) {
  return moment(str).utc().format('YYYY-MM-DD');
};

---

<div class="tw-relative">
  <div class="close_button tw-hidden">
    <svg width="29" height="28" viewBox="0 0 29 28" fill="none" xmlns="http://www.w3.org/2000/svg">
      <line y1="-1" x2="35.3553" y2="-1" transform="matrix(0.707108 0.707106 -0.707108 0.707106 2.31006 2.30957)" stroke="black" stroke-width="2"/>
      <line y1="-1" x2="35.3553" y2="-1" transform="matrix(0.707108 -0.707106 0.707108 0.707106 2.31006 27.3096)" stroke="black" stroke-width="2"/>
    </svg>
  </div>
  <canvas
    id="renderCanvasList"
    data-blog={resnublog.contents.map((content: any) => content.image.url + '|' + content.image.width + '|' + content.image.height  + '|' + content.title)}
    class="tw-hidden"
  >
  </canvas>  
  <canvas id="renderCanvasBanner" class="tw-hidden"></canvas>
</div>

<section id="renderCard" aria-label="golf_slider">
	<ul class="card-wrap tw-flex tw-flex-wrap tw-gap-[10px] tw-mr-[-10px] tw-z-[10] sm:tw-gap-[20px] sm:tw-mr-[0px]">
		{
			resnublog.contents.map( (content: any) => (
				<li class="cart-wrap-inner splide__slide">
          <img
            data-width-x={content.image.width}
            data-width-y={content.image.height}
            src={content.image.url}
            alt={content.title}
            decoding="auto"
            class="tw-w-[100%]"
          >
				</li>				
			) )
		}
	</ul>
</section>

<script type="text/javascript">
    const button_targets = document.querySelectorAll('.cart-wrap-inner');
    for(let i = 0; i < button_targets.length; i++){
      button_targets[i].addEventListener("click",(e) => {
        if (e.target.tagName === 'IMG') {
            const src = e.target.getAttribute('src');
            const width = e.target.getAttribute('data-width-x');
            const height = e.target.getAttribute('data-width-y');
            document.getElementById('renderCanvasBanner').classList.remove('tw-hidden');
            document.getElementById('renderCard').classList.add('tw-hidden');
            document.querySelector('.close_button').classList.remove('tw-hidden');
            mainbanner(src, width, height);
        }
      }, false);
    }

  document.querySelector('.close_button').addEventListener("click",(e) => { 
    document.getElementById('renderCanvasBanner').classList.add('tw-hidden');
    document.getElementById('renderCard').classList.remove('tw-hidden');
    document.querySelector('.close_button').classList.add('tw-hidden');
  });

  function bannerlist() {
    const canvasblog = document.getElementById('renderCanvasList');

    const engine = new BABYLON.Engine(canvasblog);  

    const createScene = function () {

        const canvaslist = canvasblog.dataset.blog;
        const canvaslistsplit = canvaslist.split(',');
        
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0,0,0,0); 

        const camera3 = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 18, BABYLON.Vector3.Zero(), scene);

        camera3.attachControl(canvasblog, true);

        // ライトを作成
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.specular = new BABYLON.Color3(1, 1, 1);
        light.groundColor = new BABYLON.Color3(1, 1, 1);

        // ブロックを作成
        // マテリアルをセットする
        canvaslistsplit.forEach(function( value, index ) {
          const boxMat = new BABYLON.StandardMaterial("boxMat");

          value_split = value.split('|');

          // ボックス型のジオメトリをセットする
          switch(true) {
            case String(value_split[1]).length === 5 || String(value_split[2]).length === 5:
              var wfix = value_split[1] / 2000;
              var hfix = value_split[2] / 1000;
              break;          
            case String(value_split[1]).length === 4 || String(value_split[2]).length === 4:
              var wfix = value_split[1] / 200;
              var hfix = value_split[2] / 200;
              break;
            case String(value_split[1]).length === 3 || String(value_split[2]).length === 3:
              var wfix = value_split[1] / 20;
              var hfix = value_split[2] / 20;            
              break;
            default:
              var wfix = value_split[1] / 2;
              var hfix = value_split[2] / 2;
              break;  
          }

          const box = BABYLON.MeshBuilder.CreatePlane("box", {height: hfix, width: wfix, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
          // box.rotation.x = Math.cos(index);

          boxMat.diffuseTexture = new BABYLON.Texture(value_split[0]);


          box.material = boxMat;

          console.log(box);
        });

        return scene;

    }

    const scene = createScene();
    
    engine.runRenderLoop(() => {
      scene.render();
    });
    
    window.addEventListener('resize', () => {
      engine.resize();
    });

  }

  bannerlist();

  function mainbanner(src, width, height) {

    // バナーレンダリング
    function bnrrenderfunction() {

      const canvasbanner = document.getElementById('renderCanvasBanner');
      const engine = new BABYLON.Engine(canvasbanner);  

      const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0,0,0,0); 

        const camera2 = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 18, BABYLON.Vector3.Zero(), scene);

        camera2.attachControl(canvasbanner, true);

        // ライトを作成
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.specular = new BABYLON.Color3(1, 1, 1);
        light.groundColor = new BABYLON.Color3(1, 1, 1);      

        // ブロックを作成
        // マテリアルをセットする
        const boxMat = new BABYLON.StandardMaterial("boxMat");

        // ボックス型のジオメトリをセットする
        switch(true) {
          case String(width).length === 5 || String(height).length === 5:
            var wfix = width / 1000;
            var hfix = height / 1000;
            break;          
          case String(width).length === 4 || String(height).length === 4:
            var wfix = width / 100;
            var hfix = height / 100;
            break;
          case String(width).length === 3 || String(height).length === 3:
            var wfix = width / 10;
            var hfix = height / 10;            
            break;
          default:
            var wfix = width;
            var hfix = height;
            break;  
        }

        const box = BABYLON.MeshBuilder.CreatePlane("box", {height: hfix, width: wfix, sideOrientation: BABYLON.Mesh.DOUBLESIDE});

        // テクスチャをセットする
        const get_render = document.querySelector('#renderCard li img');
        const get_images = src !== null
                ? src
                : get_render.getAttribute('src');


        if( get_images !== null ) {
            boxMat.diffuseTexture = new BABYLON.Texture(get_images);
            box.material = boxMat;
            return scene;
        }

      };

      const scene = createScene();
      
      engine.runRenderLoop(() => {
        scene.render();
      });
      
      window.addEventListener('resize', () => {
        engine.resize();
      });
    }
    bnrrenderfunction();
  }
  window.addEventListener('DOMContentLoaded', mainbanner());
</script>

<style>
  #renderCanvasList {
    position: fixed;
    width: 100%;
    height: 100vh;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  #renderCanvasBanner {
    position: fixed;
    width: 100%;
    height: 100vh;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    animation: fadein 0.5s ease-in-out 0s infinite;
    animation-fill-mode: forwards;
    animation-iteration-count: 1;
    opacity: 0;
  }
  @keyframes fadein {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
    }
    80% {
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 0.8;
    }    
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
  }

  .card-wrap {
	  height: calc(100vh - 8rem);
    overflow: scroll;
    padding: 2rem;
    top: 50%;
    right: 0%;
    transform: translate(0%,-50%);
    position: absolute;
    width: 30%;
    display: grid;
    grid-template-columns: 100%;
  }
  .cart-wrap-inner {
    backdrop-filter: blur(10px);
    padding: 2rem;
    border: 1px solid rgb(255 255 255 / 0.4);
    border-right-color: rgb(255 255 255 / 0.2);
    border-bottom-color: rgb(255 255 255 / 0.2);
    border-radius: 5px;	
    cursor: pointer;
  }
  .close_button {
    position: fixed;
    top: 74px;
    right: 20px;
    width: 30px;
    font-size: 50px;
    line-height: 30px;
    cursor: pointer;
    z-index: 10;
  }
  .close_button line {
    filter:
      drop-shadow(0px 0px 1px #ffffff)
      drop-shadow(0px 0px 1px #ffffff);
  }
</style>